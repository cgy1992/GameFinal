<!DOCTYPE html>
<html>
<head>
<title>HelloWorld</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<style type="text/css">
/* GitHub stylesheet for MarkdownPad (http://markdownpad.com) */
/* Author: Nicolas Hery - http://nicolashery.com */
/* Version: b13fe65ca28d2e568c6ed5d7f06581183df8f2ff */
/* Source: https://github.com/nicolahery/markdownpad-github */

/* RESET
=============================================================================*/

html, body, div, span, applet, object, iframe, h1, h2, h3, h4, h5, h6, p, blockquote, pre, a, abbr, acronym, address, big, cite, code, del, dfn, em, img, ins, kbd, q, s, samp, small, strike, strong, sub, sup, tt, var, b, u, i, center, dl, dt, dd, ol, ul, li, fieldset, form, label, legend, table, caption, tbody, tfoot, thead, tr, th, td, article, aside, canvas, details, embed, figure, figcaption, footer, header, hgroup, menu, nav, output, ruby, section, summary, time, mark, audio, video {
  margin: 0;
  padding: 0;
  border: 0;
}

/* BODY
=============================================================================*/

body {
  font-family: Helvetica, arial, freesans, clean, sans-serif;
  font-size: 14px;
  line-height: 1.6;
  color: #333;
  background-color: #fff;
  padding: 20px;
  max-width: 960px;
  margin: 0 auto;
}

body>*:first-child {
  margin-top: 0 !important;
}

body>*:last-child {
  margin-bottom: 0 !important;
}

/* BLOCKS
=============================================================================*/

p, blockquote, ul, ol, dl, table, pre {
  margin: 15px 0;
}

/* HEADERS
=============================================================================*/

h1, h2, h3, h4, h5, h6 {
  margin: 20px 0 10px;
  padding: 0;
  font-weight: bold;
  -webkit-font-smoothing: antialiased;
}

h1 tt, h1 code, h2 tt, h2 code, h3 tt, h3 code, h4 tt, h4 code, h5 tt, h5 code, h6 tt, h6 code {
  font-size: inherit;
}

h1 {
  font-size: 28px;
  color: #000;
}

h2 {
  font-size: 24px;
  border-bottom: 1px solid #ccc;
  color: #000;
}

h3 {
  font-size: 18px;
}

h4 {
  font-size: 16px;
}

h5 {
  font-size: 14px;
}

h6 {
  color: #777;
  font-size: 14px;
}

body>h2:first-child, body>h1:first-child, body>h1:first-child+h2, body>h3:first-child, body>h4:first-child, body>h5:first-child, body>h6:first-child {
  margin-top: 0;
  padding-top: 0;
}

a:first-child h1, a:first-child h2, a:first-child h3, a:first-child h4, a:first-child h5, a:first-child h6 {
  margin-top: 0;
  padding-top: 0;
}

h1+p, h2+p, h3+p, h4+p, h5+p, h6+p {
  margin-top: 10px;
}

/* LINKS
=============================================================================*/

a {
  color: #4183C4;
  text-decoration: none;
}

a:hover {
  text-decoration: underline;
}

/* LISTS
=============================================================================*/

ul, ol {
  padding-left: 30px;
}

ul li > :first-child, 
ol li > :first-child, 
ul li ul:first-of-type, 
ol li ol:first-of-type, 
ul li ol:first-of-type, 
ol li ul:first-of-type {
  margin-top: 0px;
}

ul ul, ul ol, ol ol, ol ul {
  margin-bottom: 0;
}

dl {
  padding: 0;
}

dl dt {
  font-size: 14px;
  font-weight: bold;
  font-style: italic;
  padding: 0;
  margin: 15px 0 5px;
}

dl dt:first-child {
  padding: 0;
}

dl dt>:first-child {
  margin-top: 0px;
}

dl dt>:last-child {
  margin-bottom: 0px;
}

dl dd {
  margin: 0 0 15px;
  padding: 0 15px;
}

dl dd>:first-child {
  margin-top: 0px;
}

dl dd>:last-child {
  margin-bottom: 0px;
}

/* CODE
=============================================================================*/

pre, code, tt {
  font-size: 12px;
  font-family: Consolas, "Liberation Mono", Courier, monospace;
}

code, tt {
  margin: 0 0px;
  padding: 0px 0px;
  white-space: nowrap;
  border: 1px solid #eaeaea;
  background-color: #f8f8f8;
  border-radius: 3px;
}

pre>code {
  margin: 0;
  padding: 0;
  white-space: pre;
  border: none;
  background: transparent;
}

pre {
  background-color: #f8f8f8;
  border: 1px solid #ccc;
  font-size: 13px;
  line-height: 19px;
  overflow: auto;
  padding: 6px 10px;
  border-radius: 3px;
}

pre code, pre tt {
  background-color: transparent;
  border: none;
}

kbd {
    -moz-border-bottom-colors: none;
    -moz-border-left-colors: none;
    -moz-border-right-colors: none;
    -moz-border-top-colors: none;
    background-color: #DDDDDD;
    background-image: linear-gradient(#F1F1F1, #DDDDDD);
    background-repeat: repeat-x;
    border-color: #DDDDDD #CCCCCC #CCCCCC #DDDDDD;
    border-image: none;
    border-radius: 2px 2px 2px 2px;
    border-style: solid;
    border-width: 1px;
    font-family: "Helvetica Neue",Helvetica,Arial,sans-serif;
    line-height: 10px;
    padding: 1px 4px;
}

/* QUOTES
=============================================================================*/

blockquote {
  border-left: 4px solid #DDD;
  padding: 0 15px;
  color: #777;
}

blockquote>:first-child {
  margin-top: 0px;
}

blockquote>:last-child {
  margin-bottom: 0px;
}

/* HORIZONTAL RULES
=============================================================================*/

hr {
  clear: both;
  margin: 15px 0;
  height: 0px;
  overflow: hidden;
  border: none;
  background: transparent;
  border-bottom: 4px solid #ddd;
  padding: 0;
}

/* TABLES
=============================================================================*/

table th {
  font-weight: bold;
}

table th, table td {
  border: 1px solid #ccc;
  padding: 6px 13px;
}

table tr {
  border-top: 1px solid #ccc;
  background-color: #fff;
}

table tr:nth-child(2n) {
  background-color: #f8f8f8;
}

/* IMAGES
=============================================================================*/

img {
  max-width: 100%
}
</style>
</head>
<body>
<h1>HelloWorld</h1>
<p>Let's look at what we were writing in the previous tutorial.</p>
<pre><code>int main()
{
    IDevice* device = createDevice(EDT_DIRECT3D11, 800, 600);
    IVideoDriver* driver = device-&gt;getVideoDriver();
    ISceneManager* smgr = device-&gt;createSceneManager();

    ITimer* timer = device-&gt;getTimer();
    timer-&gt;reset();

    const f32 color[] = { 0, 0, 0, 1.0f };
    while (device-&gt;run()) {
        driver-&gt;beginScene(true, true, color);

        float dt = timer-&gt;tick();
        smgr-&gt;update(dt);
        smgr-&gt;drawAll();

        driver-&gt;endScene();
    }

    smgr-&gt;destroy();
    device-&gt;drop();
    return 0;
}
</code></pre>

<p>The first function we called is <code>createDevice</code> under <code>gf::</code> namespace. This method returns a <code>IDevice</code> interface. Every GameFinal Application must have a device interface, which maintains the state of the window and other components in the game. The first parameter of this function represents which renderer you want to use. Here we set this to <code>EDT_DIRECT3D11</code>, which means we would like DirectX11 renderer. The second and third parameters represent the width and height of the window respectively. </p>
<p>This function contains other parameters that have default values. For instance, if you're planning to support anti-aliasing, you might want to use multi-sampling in your game like this:</p>
<pre><code>SDeviceContextSettings settings;
settings.MultiSamplingCount = 4;
settings.MultiSamplingQuality = 32;
IDevice* device = createDevice(EDT_DIRECT3D11, SCREEN_WIDTH, SCREEN_HEIGHT, EWS_NONE, true, settings);
</code></pre>

<p>The second line in the main function gets a <code>IVideoDriver</code> interface, which you can regard as an abstraction of your display device:</p>
<pre><code>IVideoDriver* driver = device-&gt;getVideoDriver();
</code></pre>

<p>The third line creates a scene manager, which is represented as a <code>ISceneManager</code> interface:</p>
<pre><code>IVideoDriver* driver = device-&gt;getVideoDriver();
</code></pre>

<p>However, in this program, we put nothing into the scene, so we didn't add anything to this scene manager.</p>
<p>The we get a timer from the <code>IDevice</code> interface and reset its value. Remember to reset a timer before the actual game loop begins:</p>
<pre><code>ITimer* timer = device-&gt;getTimer();
timer-&gt;reset();
</code></pre>

<p>After all these preparations, the program enters the game loop:</p>
<pre><code>while (device-&gt;run()) {
    float dt = timer-&gt;tick();
    smgr-&gt;update(dt);
    driver-&gt;beginScene(true, true, color);        
    smgr-&gt;drawAll();
    driver-&gt;endScene();
}
</code></pre>

<p>Inside the game loop, we first call <code>timer-&gt;tick()</code>. This method would return the elapsed seconds between this calling and previous calling. Then we call <code>smgr-&gt;update(dt)</code> to update all the objects in the scene. Then we begin  to do the rendering: all the rendering work should be put between <code>beginScene</code> and <code>endScene</code>. We just call <code>smgr-&gt;drawAll()</code> to render all the objects in the scene, though in this program there is nothing to render in the scene.</p>
<p>Let's try to modify the value of the third parameter of <code>beginScene</code> method:</p>
<pre><code>const f32 color[] = { 1.0f, 0, 0, 1.0f };
</code></pre>

<p>Then re-run the program, the engine now uses red to flush the screen's buffer.</p>
<h2>Manage Resources</h2>
<p>Every game has to manager lots of resources. In GameFinal, we don't need to give the full path for every resource file every time you need to load a resource.  </p>
<p>Firstly, we create a new file called <code>Resources.cfg</code> under the project's folder. Then copy the <code>built-in-resources</code> folder to project's folder. Open this <code>Resources.cfg</code> in any text editor and add the following text:</p>
<pre><code>[BUILT-IN]
FileSystem=./built-in-resources
</code></pre>

<p>The word inside the bracket gives the name of a <code>resource group</code>. All the lines following this word belong to the same group. Here the group is called <code>BUILT-IN</code>. Then we add a path to the group(<code>./built-in-resources</code>). During the game's running, all the files under this folder could be detected automatically. For example, we can write <code>teapot.mesh</code> for short instead of giving the full path <code>./built-in-resources</code> now in program.</p>
<p>In code, we use <code>IResourceGroupManager</code> interface to manage all the resources:</p>
<pre><code>IResourceGroupManager* resourceGroupManager = driver-&gt;getResourceGroupManager();
resourceGroupManager-&gt;init(&quot;Resources.cfg&quot;);
</code></pre>

<p>Here we call <code>init</code> method to initialize all the resources defined in the <code>Resources.cgf</code>. The engine indexes and  maintains those resources. </p>
<h2>Draw Something</h2>
<p>Let's begin to draw something on the screen. We're going to set up a scene containing a sphere object on the ground.</p>
<p>After creating the scene manager, we add a mesh node representing the ground to the scene manager:</p>
<pre><code>// create ground's material
SMaterial groundMaterial;
groundMaterial.setAttribute(&quot;ambient&quot;, XMFLOAT4(0.5f, 0.5f, 0.5f, 1.0f));
groundMaterial.setAttribute(&quot;diffuse&quot;, XMFLOAT4(0.5f, 0.5f, 0.5f, 1.0f));
groundMaterial.setAttribute(&quot;specular&quot;, XMFLOAT4(0.05f, 0.05f, 0.05f, 32.0f));
groundMaterial.setAttribute(&quot;emissive&quot;, XMFLOAT4(0.0f, 0.0f, 0.0f, 1.0f));
groundMaterial.setPipeline(&quot;gf/geometry_dirlight&quot;);

// create ground's mesh
ISimpleMesh* groundMesh = meshManager-&gt;createPlaneMesh(&quot;ground&quot;, 100.0f, 100.0f, 10, 10);

// add a mesh node to the scene manager
IMeshNode* groundNode = smgr-&gt;addMeshNode(groundMesh, &amp;groundMaterial, nullptr, true);
</code></pre>

<p>Firstly, we need to define the ground's material by a <code>SMaterial</code> structure. We call the <code>setAttribute</code> function to set its four attributes: ambient, diffuse, specular, emissive. These values define how much light would be reflected by the surface. Then we call <code>setPipeline</code> to set the pipeline this material would like to use. A pipeline defines the whole process of how the engine would render an object on the screen. Here we set its value as <code>gf/geometry_dirlight</code>, which is a built-in pipeline provided by the engine. </p>
<p>Then we call the <code>meshManager-&gt;createPlaneMesh</code> to create a plane mesh:</p>
<pre><code>ISimpleMesh* groundMesh = meshManager-&gt;createPlaneMesh(&quot;ground&quot;, 100.0f, 100.0f, 10, 10);
</code></pre>

<p>The first parameter is the mesh's name. You can name it whatever you like here. The second and third parameters are the length and width of the plane. The fourth and fifth parameters define how many tiles (10 * 10) inside the plane. </p>
<p>After we create the mesh, we add a node with this mesh into the scene:</p>
<pre><code>IMeshNode* groundNode = smgr-&gt;addMeshNode(groundMesh, &amp;groundMaterial, nullptr, true);
</code></pre>

<p>We call the <code>smgr-&gt;addMeshNode</code> method to create a mesh node. The first parameter represents the mesh that we have created. The material <code>groundMaterial</code> that we have created are passed as its second parameter. The third parameter defines the node's parent, <code>nullptr</code> means its parent is the scene manager. The fourth parameter defines whether it is a static node. <code>Static</code> means the object will never move during the game.</p>
<p>Then we add a sphere object in the same way:</p>
<pre><code>// create sphere's material
SMaterial sphereMaterial;
sphereMaterial.setAttribute(&quot;ambient&quot;, XMFLOAT4(0.7f, 0.5f, 0.1f, 1.0f));
sphereMaterial.setAttribute(&quot;diffuse&quot;, XMFLOAT4(1.0f, 0.9f, 0.17f, 1.0f));
sphereMaterial.setAttribute(&quot;specular&quot;, XMFLOAT4(0.5f, 0.5f, 0.5f, 32.0f));
sphereMaterial.setAttribute(&quot;emissive&quot;, XMFLOAT4(0.0f, 0.0f, 0.0f, 1.0f));
sphereMaterial.setPipeline(&quot;gf/geometry_dirlight&quot;);

ISimpleMesh* sphereMesh = meshManager-&gt;createSphereMesh(&quot;sphere&quot;, 1.0f, 100, 100);
IMeshNode* sphereNode = smgr-&gt;addMeshNode(sphereMesh, &amp;sphereMaterial, nullptr, true, XMFLOAT3(0, 1.0f, 0));
</code></pre>

<p>The sphere's radius is set to 1.0f, and we put it in the position of <code>(0, 1.0f, 0)</code>; so the sphere touches the ground precisely.</p>
<p>Although we finished adding geometries into scene, it is not enough; because so far we didn't add any light source into the scene. So now we begin creating a directional light:</p>
<pre><code>ILightNode* light = smgr-&gt;addDirectionalLight(1, nullptr, XMFLOAT3(1.0f, -1.0f, 1.0f));
light-&gt;setSpecular(XMFLOAT4(1.0f, 1.0, 1.0f, 32.0f));
light-&gt;setDiffuse(XMFLOAT4(0.8f, 0.8f, 0.8f, 1.0f));
</code></pre>

<p>The first parameter of <code>addDirectionalLight</code> is the id of light. Here the light's id is 1. The direction of the light is given as <code>(5.0f, -5.0f, 2.0f)</code>. We also call <code>setSpecular</code> and <code>setDiffuse</code> method to set the light's diffuse and specular color. </p>
<p>Usually, we want to add some environmental light. We can do this by calling <code>setAmbient</code> method:</p>
<pre><code>smgr-&gt;setAmbient(XMFLOAT4(0.8f, 0.8f, 0.8f, 1.0f));
</code></pre>

<p>The last thing is to add a camera which gives the position and orientation of the player's eyes.</p>
<pre><code>ICameraNode* camera = smgr-&gt;addCameraNode(1, nullptr, XMFLOAT3(0, 1.0f, -6.0f), 
    XMFLOAT3(0, 1.0f, 0.0f), XMFLOAT3(0, 1.0f, 0));
</code></pre>

<p>The first parameter is the camera's id. Here we put the camera in the position of <code>(0, 1.0f, -6.0)</code>. The target position that the camera looks at is given as <code>(0, 1.0f, 0)</code>. The ups vector of the camera is <code>(0, 1, 0)</code>.</p>
<p>Finally, we compile and run our program, we could see the window:</p>
<p><img src="https://raw.githubusercontent.com/woyaofacai/GameFinal/199694ecea56b119e69d5c18e625473fc3b0a7b8/Tutorials/img/01-01.png" /></p>
<p>The entire code is given at last:)</p>
<pre><code>#include &lt;GameFinal.h&gt;

#pragma comment(lib, &quot;GameFinal.lib&quot;)
#pragma comment(lib, &quot;winmm.lib&quot;)

using namespace gf;

int main()
{
    IDevice* device = createDevice(EDT_DIRECT3D11, 800, 600);
    IVideoDriver* driver = device-&gt;getVideoDriver();

    ISceneManager* smgr = device-&gt;createSceneManager();

    IResourceGroupManager* resourceGroupManager = driver-&gt;getResourceGroupManager();
    resourceGroupManager-&gt;init(&quot;Resources.cfg&quot;);

    // get mesh manager.
    IMeshManager* meshManager = driver-&gt;getMeshManager();

    // set up ground.
    // create ground's material
    SMaterial groundMaterial;
    groundMaterial.setAttribute(&quot;ambient&quot;, XMFLOAT4(0.5f, 0.5f, 0.5f, 1.0f));
    groundMaterial.setAttribute(&quot;diffuse&quot;, XMFLOAT4(0.5f, 0.5f, 0.5f, 1.0f));
    groundMaterial.setAttribute(&quot;specular&quot;, XMFLOAT4(0.05f, 0.05f, 0.05f, 32.0f));
    groundMaterial.setAttribute(&quot;emissive&quot;, XMFLOAT4(0.0f, 0.0f, 0.0f, 1.0f));
    groundMaterial.setPipeline(&quot;gf/geometry_dirlight&quot;);

    // create ground's mesh
    ISimpleMesh* groundMesh = meshManager-&gt;createPlaneMesh(&quot;ground&quot;, 100.0f, 100.0f, 10, 10);

    // add a mesh node to the scene manager
    IMeshNode* groundNode = smgr-&gt;addMeshNode(groundMesh, &amp;groundMaterial, nullptr, true);

    // create sphere's material
    SMaterial sphereMaterial;
    sphereMaterial.setAttribute(&quot;ambient&quot;, XMFLOAT4(0.7f, 0.5f, 0.1f, 1.0f));
    sphereMaterial.setAttribute(&quot;diffuse&quot;, XMFLOAT4(1.0f, 0.9f, 0.17f, 1.0f));
    sphereMaterial.setAttribute(&quot;specular&quot;, XMFLOAT4(0.5f, 0.5f, 0.5f, 32.0f));
    sphereMaterial.setAttribute(&quot;emissive&quot;, XMFLOAT4(0.0f, 0.0f, 0.0f, 1.0f));
    sphereMaterial.setPipeline(&quot;gf/geometry_dirlight&quot;);

    ISimpleMesh* sphereMesh = meshManager-&gt;createSphereMesh(&quot;sphere&quot;, 1.0f, 100, 100);
    IMeshNode* sphereNode = smgr-&gt;addMeshNode(sphereMesh, &amp;sphereMaterial, nullptr, true, 
                        XMFLOAT3(0, 1.0f, 0));

    // add directional light
    ILightNode* light = smgr-&gt;addDirectionalLight(1, nullptr, XMFLOAT3(5.0f, -5.0f, 2.0f));
    light-&gt;setSpecular(XMFLOAT4(1.0f, 1.0, 1.0f, 32.0f));
    light-&gt;setDiffuse(XMFLOAT4(0.8f, 0.8f, 0.8f, 1.0f));

    // set scene's environmental light 
    smgr-&gt;setAmbient(XMFLOAT4(0.8f, 0.8f, 0.8f, 1.0f));

    // create camera
    ICameraNode* camera = smgr-&gt;addCameraNode(1, nullptr, XMFLOAT3(0, 1.0f, -6.0f), 
        XMFLOAT3(0, 1.0f, 0.0f), XMFLOAT3(0, 1.0f, 0));

    ITimer* timer = device-&gt;getTimer();
    timer-&gt;reset();

    const f32 color[] = { 0, 0, 0, 1.0f };
    while (device-&gt;run()) {

        float dt = timer-&gt;tick();
        smgr-&gt;update(dt);
        driver-&gt;beginScene(true, true, color);
        smgr-&gt;drawAll();
        driver-&gt;endScene();
    }

    smgr-&gt;destroy();
    device-&gt;drop();

    return 0;
}
</code></pre>


</body>
</html>
<!-- This document was created with MarkdownPad, the Markdown editor for Windows (http://markdownpad.com) -->
