<!DOCTYPE html>
<html>
<head>
<title>Instancing</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<style type="text/css">
/* GitHub stylesheet for MarkdownPad (http://markdownpad.com) */
/* Author: Nicolas Hery - http://nicolashery.com */
/* Version: b13fe65ca28d2e568c6ed5d7f06581183df8f2ff */
/* Source: https://github.com/nicolahery/markdownpad-github */

/* RESET
=============================================================================*/

html, body, div, span, applet, object, iframe, h1, h2, h3, h4, h5, h6, p, blockquote, pre, a, abbr, acronym, address, big, cite, code, del, dfn, em, img, ins, kbd, q, s, samp, small, strike, strong, sub, sup, tt, var, b, u, i, center, dl, dt, dd, ol, ul, li, fieldset, form, label, legend, table, caption, tbody, tfoot, thead, tr, th, td, article, aside, canvas, details, embed, figure, figcaption, footer, header, hgroup, menu, nav, output, ruby, section, summary, time, mark, audio, video {
  margin: 0;
  padding: 0;
  border: 0;
}

/* BODY
=============================================================================*/

body {
  font-family: Helvetica, arial, freesans, clean, sans-serif;
  font-size: 14px;
  line-height: 1.6;
  color: #333;
  background-color: #fff;
  padding: 20px;
  max-width: 960px;
  margin: 0 auto;
}

body>*:first-child {
  margin-top: 0 !important;
}

body>*:last-child {
  margin-bottom: 0 !important;
}

/* BLOCKS
=============================================================================*/

p, blockquote, ul, ol, dl, table, pre {
  margin: 15px 0;
}

/* HEADERS
=============================================================================*/

h1, h2, h3, h4, h5, h6 {
  margin: 20px 0 10px;
  padding: 0;
  font-weight: bold;
  -webkit-font-smoothing: antialiased;
}

h1 tt, h1 code, h2 tt, h2 code, h3 tt, h3 code, h4 tt, h4 code, h5 tt, h5 code, h6 tt, h6 code {
  font-size: inherit;
}

h1 {
  font-size: 28px;
  color: #000;
}

h2 {
  font-size: 24px;
  border-bottom: 1px solid #ccc;
  color: #000;
}

h3 {
  font-size: 18px;
}

h4 {
  font-size: 16px;
}

h5 {
  font-size: 14px;
}

h6 {
  color: #777;
  font-size: 14px;
}

body>h2:first-child, body>h1:first-child, body>h1:first-child+h2, body>h3:first-child, body>h4:first-child, body>h5:first-child, body>h6:first-child {
  margin-top: 0;
  padding-top: 0;
}

a:first-child h1, a:first-child h2, a:first-child h3, a:first-child h4, a:first-child h5, a:first-child h6 {
  margin-top: 0;
  padding-top: 0;
}

h1+p, h2+p, h3+p, h4+p, h5+p, h6+p {
  margin-top: 10px;
}

/* LINKS
=============================================================================*/

a {
  color: #4183C4;
  text-decoration: none;
}

a:hover {
  text-decoration: underline;
}

/* LISTS
=============================================================================*/

ul, ol {
  padding-left: 30px;
}

ul li > :first-child, 
ol li > :first-child, 
ul li ul:first-of-type, 
ol li ol:first-of-type, 
ul li ol:first-of-type, 
ol li ul:first-of-type {
  margin-top: 0px;
}

ul ul, ul ol, ol ol, ol ul {
  margin-bottom: 0;
}

dl {
  padding: 0;
}

dl dt {
  font-size: 14px;
  font-weight: bold;
  font-style: italic;
  padding: 0;
  margin: 15px 0 5px;
}

dl dt:first-child {
  padding: 0;
}

dl dt>:first-child {
  margin-top: 0px;
}

dl dt>:last-child {
  margin-bottom: 0px;
}

dl dd {
  margin: 0 0 15px;
  padding: 0 15px;
}

dl dd>:first-child {
  margin-top: 0px;
}

dl dd>:last-child {
  margin-bottom: 0px;
}

/* CODE
=============================================================================*/

pre, code, tt {
  font-size: 12px;
  font-family: Consolas, "Liberation Mono", Courier, monospace;
}

code, tt {
  margin: 0 0px;
  padding: 0px 0px;
  white-space: nowrap;
  border: 1px solid #eaeaea;
  background-color: #f8f8f8;
  border-radius: 3px;
}

pre>code {
  margin: 0;
  padding: 0;
  white-space: pre;
  border: none;
  background: transparent;
}

pre {
  background-color: #f8f8f8;
  border: 1px solid #ccc;
  font-size: 13px;
  line-height: 19px;
  overflow: auto;
  padding: 6px 10px;
  border-radius: 3px;
}

pre code, pre tt {
  background-color: transparent;
  border: none;
}

kbd {
    -moz-border-bottom-colors: none;
    -moz-border-left-colors: none;
    -moz-border-right-colors: none;
    -moz-border-top-colors: none;
    background-color: #DDDDDD;
    background-image: linear-gradient(#F1F1F1, #DDDDDD);
    background-repeat: repeat-x;
    border-color: #DDDDDD #CCCCCC #CCCCCC #DDDDDD;
    border-image: none;
    border-radius: 2px 2px 2px 2px;
    border-style: solid;
    border-width: 1px;
    font-family: "Helvetica Neue",Helvetica,Arial,sans-serif;
    line-height: 10px;
    padding: 1px 4px;
}

/* QUOTES
=============================================================================*/

blockquote {
  border-left: 4px solid #DDD;
  padding: 0 15px;
  color: #777;
}

blockquote>:first-child {
  margin-top: 0px;
}

blockquote>:last-child {
  margin-bottom: 0px;
}

/* HORIZONTAL RULES
=============================================================================*/

hr {
  clear: both;
  margin: 15px 0;
  height: 0px;
  overflow: hidden;
  border: none;
  background: transparent;
  border-bottom: 4px solid #ddd;
  padding: 0;
}

/* TABLES
=============================================================================*/

table th {
  font-weight: bold;
}

table th, table td {
  border: 1px solid #ccc;
  padding: 6px 13px;
}

table tr {
  border-top: 1px solid #ccc;
  background-color: #fff;
}

table tr:nth-child(2n) {
  background-color: #f8f8f8;
}

/* IMAGES
=============================================================================*/

img {
  max-width: 100%
}
</style>
</head>
<body>
<h1>Instancing</h1>
<p>This tutorial will tell you how to render many many meshes in the same scene with the help of instancing. Instancing is a new feature that allows developers to render multiple objects in the same call, and thus save the performance. GameFinal supports instancing in a simple way, you can create many instances of the same mesh in the scene and the scene manager will help to manage those instances. In this tutorial, we would plant many trees on the terrain we created in the previous tutorial.</p>
<pre><code>IModelMesh* treeMesh = meshManager-&gt;getModelMesh(&quot;roundtreeA.mesh&quot;);
IInstanceCollectionNode* collection = smgr-&gt;addInstanceCollectionNode(treeMesh, nullptr, 300, 0);

for (u32 i = 0; i &lt; 300; i++) {
    addTreeInstance(collection, terrainMesh);
}

collection-&gt;addShadow(1);
</code></pre>

<p>The program first loads the tree mesh and get a <code>IMeshMesh</code>. Then we need to to create a <code>IInstanceCollectionNode</code> interface. This interface is the root of all the instances and manages those instances under it. In order to create this interface, we call the <code>ISceneManager::addInstanceCollectionNode</code>. We pass the tree mesh as its first parameter. Then all the instances under this instance collection would share this mesh. The second parameter is the node's parent, <code>nullptr</code> means the scene manager. The third parameter specifies the maximum number of instances under the collection node. The fourth parameter specifies the extra space the engine would allocate for each vertex. Here we set it to 0.</p>
<p>Then we use a <code>for</code> loop to add 300 instances of trees to the collection node. The <code>addTreeInstance</code> function is defined like this:</p>
<pre><code>void addTreeInstance(IInstanceCollectionNode* collection, ITerrainMesh* terrain)
{
    const static f32 range = 200;
    f32 x = math::RandomFloat(-range, range);
    f32 z = math::RandomFloat(-range, range);
    f32 y = terrain-&gt;getHeight(x, z);

    IInstanceNode* treeNode = collection-&gt;addInstance(true, XMFLOAT3(x, y, z));
    treeNode-&gt;addShadow(1);
}
</code></pre>

<p>We put the tree at a random position on the terrain. We call the <code>IInstanceCollectionNode::addInstance</code> to add the instance into the collection node. The first parameter specifies whether it is static. The second parameter specifies the instance's position.</p>
<p>In addition, we need make a few modifications in the shader code. First, the structure of vertex should be changed:</p>
<pre><code>struct VertexIn
{
    float3 PosL     : POSITION;
    float3 Normal   : NORMAL;
    float2 Tex      : TEXCOORD;
    GF_DECLARE_INTANCES_VERTEX   // must add this when using instancing
};
</code></pre>

<p>You may notice that at end of the VertexIn structure, we add a built-in macro <code>GF_DECLARE_INTANCES_VERTEX</code>. Then in the vertex shader, we have to replace <code>GF_WORLD</code> with the <code>INSTANCE_WORLD</code>:</p>
<pre><code>VertexOut vs_main(VertexIn vin)
{
    VertexOut vout;
    float4 PosW = mul(float4(vin.PosL, 1.0f), INSTANCE_WORLD);
    vout.Normal = mul(vin.Normal, (float3x3)INSTANCE_WORLD);
    vout.PosH = mul(PosW, GF_VIEW_PROJ);
    vout.PosW = PosW.xyz;
    vout.Tex = vin.Tex;
    return vout;
}
</code></pre>

<p>Furthermore, we have to change the <code>input-layout</code> in the pipeline. We must include the positon of each instance , namely the world transformation, into each vertex. We define the pipeline like this:</p>
<pre><code>&lt;pipeline name=&quot;tree_pipeline&quot;&gt;
    &lt;input-layout&gt;
        &lt;element semantic=&quot;POSITION&quot; format=&quot;float3&quot;/&gt;
        &lt;element semantic=&quot;NORMAL&quot; format=&quot;float3&quot;/&gt;
        &lt;element semantic=&quot;TEXCOORD&quot; format=&quot;float2&quot;/&gt;
        &lt;element semantic=&quot;WORLD&quot; index=&quot;0&quot; format=&quot;float4&quot; slot=&quot;1&quot; instance=&quot;true&quot; instance-rate=&quot;1&quot;/&gt;
        &lt;element semantic=&quot;WORLD&quot; index=&quot;1&quot; format=&quot;float4&quot; slot=&quot;1&quot; instance=&quot;true&quot; instance-rate=&quot;1&quot;/&gt;
        &lt;element semantic=&quot;WORLD&quot; index=&quot;2&quot; format=&quot;float4&quot; slot=&quot;1&quot; instance=&quot;true&quot; instance-rate=&quot;1&quot;/&gt;
        &lt;element semantic=&quot;WORLD&quot; index=&quot;3&quot; format=&quot;float4&quot; slot=&quot;1&quot; instance=&quot;true&quot; instance-rate=&quot;1&quot;/&gt;
    &lt;/input-layout&gt;
    .....
&lt;/pipeline&gt;
</code></pre>

<p>After finishing all these modifications, we can run the program now:</p>
<p><img src="https://raw.githubusercontent.com/woyaofacai/GameFinal/master/Tutorials/img/08-02.png" /></p>
<p>Even although we created so many trees in the scene, the program could run very smoothly.</p>

</body>
</html>
<!-- This document was created with MarkdownPad, the Markdown editor for Windows (http://markdownpad.com) -->
